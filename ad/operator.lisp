(declaim (optimize (speed 3) (debug 1) (safety 0)))

(in-package :th)

(defmethod $broadcast ((c number) (m tensor))
  ($mul! ($one m) c))

(defgeneric $krows (vector n))
(defgeneric $kcols (vector n))

(defmethod $krows ((vector tensor) n) ($vv (ones n) vector))
(defmethod $kcols ((vector tensor) n) ($vv vector (ones n)))

(defmethod $broadcast ((vector tensor) (matrix tensor))
  (let ((nv ($count vector))
        (sz ($size matrix)))
    (cond ((eq nv ($ sz 1)) ($krows vector ($ sz 0)))
          ((eq nv ($ sz 0)) ($kcols vector ($ sz 1)))
          (t (error "cannot broadcast automatically")))))

(defmethod $broadcast ((c node) (m node))
  (let ((result (node ($mul! ($one ($data m)) ($data c)))))
    (setf ($name result) "BROADCAST")
    ($gp! result c)
    ($pfn! c (lambda () ($dot ($one ($data m)) ($gradient result))))
    result))

(defmethod $add ((a node) (b node))
  (let ((result (node ($add ($data a) ($data b)))))
    (setf ($name result) "ADD")
    ($gp! result a b)
    ($pfn! a (lambda () ($gradient result)))
    ($pfn! b (lambda () ($gradient result)))
    result))

(defmethod $sub ((a node) (b node))
  (let ((result (node ($sub ($data a) ($data b)))))
    (setf ($name result) "SUB")
    ($gp! result a b)
    ($pfn! a (lambda () ($gradient result)))
    ($pfn! b (lambda () ($neg ($gradient result))))
    result))

(defmethod $neg ((a node))
  (let ((result (node ($neg ($data a)))))
    (setf ($name result) "NEG")
    ($gp! result a)
    ($pfn! a (lambda () ($neg ($gradient result))))
    result))

(defmethod $dot ((a node) (b node))
  (let ((result (node ($dot ($data a) ($data b)))))
    (setf ($name result) "DOT")
    ($gp! result a b)
    ($pfn! a (lambda () ($mul ($data b) ($gradient result))))
    ($pfn! b (lambda () ($mul ($data a) ($gradient result))))
    result))

(defmethod $mv ((m node) (v node))
  (let ((result (node ($mv ($data m) ($data v)))))
    (setf ($name result) "MV")
    ($gp! result m v)
    ($pfn! m (lambda () ($vv ($gradient result) ($data v))))
    ($pfn! v (lambda () ($@ ($transpose ($data m)) ($gradient result))))
    result))

(defmethod $mm ((a node) (b node))
  (let ((result (node ($mm ($data a) ($data b)))))
    (setf ($name result) "MM")
    ($gp! result a b)
    ($pfn! a (lambda () ($mm ($gradient result) ($transpose ($data b)))))
    ($pfn! b (lambda () ($mm ($transpose ($data a)) ($gradient result))))
    result))

(defmethod $mul ((a node) (b node))
  (let ((result (node ($mul ($data a) ($data b)))))
    (setf ($name result) "MUL")
    ($gp! result a b)
    ($pfn! a (lambda () ($mul ($data b) ($gradient result))))
    ($pfn! b (lambda () ($mul ($data a) ($gradient result))))
    result))

(defmethod $bmm ((bx node) (by node))
  (let ((result (node ($bmm ($data bx) ($data by)))))
    (setf ($name result) "BMM")
    ($gp! result bx by)
    ($pfn! bx (lambda () ($bmm ($gradient result) ($transpose ($data by) 2 1))))
    ($pfn! by (lambda () ($bmm ($transpose ($data bx) 2 1) ($gradient result))))
    result))

(defmethod $mml ((x node) (y node))
  (cond ((and (eq 1 ($ndim x)) (eq 1 ($ndim y))) ($dot x y))
        ((and (eq 2 ($ndim x)) (eq 1 ($ndim y))) ($mv x y))
        ((and (eq 2 ($ndim x)) (eq 2 ($ndim y))) ($mm x y))
        ((and (eq 3 ($ndim x)) (eq 3 ($ndim y))) ($bmm x y))))

(defmethod $div ((a node) (b node))
  (let ((result (node ($div ($data a) ($data b)))))
    (setf ($name result) "DIV")
    ($gp! result a b)
    ($pfn! a (lambda () ($div ($gradient result) ($data b))))
    ($pfn! b (lambda () ($neg! ($div ($mul ($data a) ($gradient result))
                                     ($expt ($data b) 2)))))
    result))

(defmethod $vv ((a node) (b node))
  (let ((result (node ($vv ($data a) ($data b)))))
    (setf ($name result) "VV")
    ($gp! result a b)
    ($pfn! a (lambda () ($mv ($gradient result) ($data b))))
    ($pfn! b (lambda () ($mv ($transpose ($gradient result)) ($data a))))
    result))

(defmethod $inverse ((a node))
  (let ((result (node ($inverse ($data a)))))
    (setf ($name result) "INVERSE")
    ($gp! result a)
    ($pfn! a (lambda ()
               (let ((tnode ($transpose ($data result))))
                 ($neg! ($mm ($mm tnode ($gradient result)) tnode)))))
    result))

(defmethod $view ((a node) &rest sizes)
  (let ((result (node (apply #'$view ($data a) sizes))))
    (setf ($name result) "VIEW")
    ($gp! result a)
    ($pfn! a (lambda () ($view ($gradient result) ($data a))))
    result))

(defmethod $expand ((a node) size)
  (let ((result (node ($expand ($data a) size))))
    (setf ($name result) "EXPAND")
    ($gp! result a)
    ($pfn! a (lambda ()
               (let* ((adata ($data a))
                      (asize ($size adata))
                      (out ($gradient result)))
                 (loop :for dim :from 0 :below ($count asize)
                       :for sz = ($ asize dim)
                       :do (when (eq sz 1)
                             (setf out ($sum out dim))))
                 out)))
    result))

(defmethod $sum ((x node) &optional (dimension -1))
  (let ((result (node ($sum ($data x) dimension))))
    (setf ($name result) "SUM")
    ($gp! result x)
    ($pfn! x (lambda ()
               (if (< dimension 0)
                   ($broadcast ($gradient result) ($data x))
                   ($expand ($gradient result) ($size x)))))
    result))

(defmethod $mean ((x node) &optional (dimension -1))
  (let ((result (node ($sum ($data x) dimension))))
    (setf ($name result) "SUM")
    ($gp! result x)
    ($pfn! x (lambda ()
               (if (< dimension 0)
                   ($broadcast (/ ($gradient result) ($count ($data x))) ($data x))
                   ($div! ($expand ($gradient result) ($size x))
                          ($size ($data x) dimension)))))
    result))

(defun seteq! (a b v)
  (let ((m ($eq a b)))
    ($mul! ($copy! ($resize! ($empty a) a) m) v)))

(defmethod $min ((x node) &optional (dimension -1))
  (let ((result (node ($min ($data x) dimension))))
    (setf ($name result) "MIN")
    ($gp! result x)
    ($pfn! x (lambda ()
               (if (< dimension 0)
                   (seteq! ($data x) ($data result) ($gradient result))
                   (seteq! ($data x)
                           ($expand ($data result) ($size x))
                           ($expand ($gradient result) ($size x))))))
    result))

(defmethod $max ((x node) &optional (dimension -1))
  (let ((result (node ($max ($data x) dimension))))
    (setf ($name result) "MAX")
    ($gp! result x)
    ($pfn! x (lambda ()
               (if (< dimension 0)
                   (seteq! ($data x) ($data result) ($gradient result))
                   (seteq! ($data x)
                           ($expand ($data result) ($size x))
                           ($expand ($gradient result) ($size x))))))
    result))

(defmethod $transpose ((x node) &optional dimension0 dimension1)
  (let ((result (node ($transpose ($data x) dimension0 dimension1))))
    (setf ($name result) "TRANSPOSE")
    ($gp! result x)
    ($pfn! x (lambda () ($transpose ($gradient result) dimension0 dimension1)))
    result))

(defmethod $reshape ((x node) &rest sizes)
  (let ((result (node (apply #'$reshape ($data x) sizes))))
    (setf ($name result) "RESHAPE")
    ($gp! result x)
    ($pfn! x (lambda () ($view ($gradient result) ($data x))))
    result))

(defmethod $clone ((x node))
  (let ((result (node ($clone ($data x)))))
    (setf ($name result) "CLONE")
    ($gp! result x)
    ($pfn! x (lambda () ($gradient result)))
    result))

(defmethod $cat ((x node) (y node) &optional (dimension 0))
  (let ((result (node ($cat ($data x) ($data y) dimension))))
    (setf ($name result) "CAT")
    ($gp! result x y)
    ($pfn! x (lambda () ($narrow ($gradient result) dimension 0 ($size ($data x) 1))))
    ($pfn! y (lambda () ($narrow ($gradient result) dimension ($size ($data x) 1)
                                 ($size ($data y) 1))))
    result))

(defmethod $concat ((x node) nodes &rest others)
  (let ((pd ($last others)))
    (if (numberp pd)
        (let ((dimension pd)
              (xs (cons x (cons nodes (butlast others)))))
          (reduce (lambda (r n) ($cat r n dimension)) xs))
        (let ((dimension 0)
              (xs (cons x (cons nodes others))))
          (reduce (lambda (r n) ($cat r n dimension)) xs)))))

(defmethod $index ((x node) dimension (indices list))
  (let ((result (node ($index ($data x) dimension indices))))
    (setf ($name result) "INDEX")
    ($gp! result x)
    ($pfn! x (lambda ()
               (let* ((g ($zero ($data x)))
                      (gs ($index g dimension indices)))
                 (setf ($index g dimension indices)
                       (apply #'$reshape ($gradient result) ($size gs)))
                 g)))
    result))

(defmethod $index ((x node) dimension (index number))
  (let ((result (node ($index ($data x) dimension index))))
    (setf ($name result) "INDEX")
    ($gp! result x)
    ($pfn! x (lambda ()
               (let* ((indices (list index))
                      (g ($zero ($data x)))
                      (gs ($index g dimension indices)))
                 (setf ($index g dimension indices)
                       (apply #'$reshape ($gradient result) ($size gs)))
                 g)))
    result))

;; (defmethod $ ((x node) location &rest others-and-default)
;;   (let ((result (node (apply #'$ ($data x) (cons location others-and-default)))))
;;     (setf ($name result) "$")
;;     ($gp! result x)
;;     ($pfn! x (lambda ()
;;                (let ((z ($zero ($data x)))
;;                      (locs (cons location others-and-default)))
;;                  (if (= ($count locs) ($ndim z))
;;                      (setf (apply #'$ z locs) ($gradient result))
;;                      ($copy! (apply #'$ z (cons location others-and-default)) ($gradient result)))
;;                  z)))
;;     result))

;; (defmethod (setf $) (value (x node) location &rest others)
;;   (let ((nx ($clone ($data x))))
;;     (setf (apply #'$ nx (cons location others)) value)
;;     (let ((result (node nx)))
;;       (setf ($name result) "SET$")
;;       ($gp! result x value)
;;       ($pfn! x (lambda ()
;;                  (let ((ng ($clone ($gradient result))))
;;                    (setf (apply #'$ ng (cons location others)) 0)
;;                    ng)))
;;       ($pfn! value (lambda ()
;;                      (let ((gk (apply #'$ ($gradient result) (cons location others))))
;;                        (if (numberp gk)
;;                            gk
;;                            ($clone gk)))))
;;       result)))
