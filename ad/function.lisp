(in-package :th)

(defun broadcast-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((c ($c0 node)))
                             (list (if ($gradientp c)
                                       ($bp! c ($dot ($one ($data node)) gradient))
                                       c)))))
  node)

(defmethod $broadcast ((c node) (m node))
  (let ((result (node ($mul! ($one ($data m)) ($data c)))))
    (setf ($children result) (list c))
    (setf ($gradientp result) ($gradientp c))
    (setf ($bpfn result) #'broadcast-backprop)
    result))

(defun add-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node)
        (mapcar (lambda (c)
                  (if ($gradientp c)
                      ($bp! c gradient)
                      c))
                ($children node)))
  node)

(defmethod $add ((a node) (b node))
  (let ((result (node ($add ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'add-backprop)
    result))

(defun sub-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a) ($bp! a gradient) a)
                                   (if ($gradientp b) ($bp! b ($neg gradient)) b)))))
  node)

(defmethod $sub ((a node) (b node))
  (let ((result (node ($sub ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'sub-backprop)
    result))

(defun neg-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node)))
                             (list (if ($gradientp a) ($bp! a ($neg gradient)) a)))))
  node)

(defmethod $neg ((a node))
  (let ((result (node ($neg ($data a)))))
    (setf ($children result) (list a))
    (setf ($gradientp result) ($gradientp a))
    (setf ($bpfn result) #'neg-backprop)
    result))

(defun dot-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a) ($bp! a ($* ($data b) gradient)) a)
                                   (if ($gradientp b) ($bp! b ($* ($data a) gradient)) b)))))
  node)

(defmethod $dot ((a node) (b node))
  (let ((result (node ($dot ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'dot-backprop)
    result))

(defun mv-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((m ($c0 node))
                                 (v ($c1 node)))
                             (list (if ($gradientp m)
                                       ($bp! m ($vv gradient ($data v)))
                                       m)
                                   (if ($gradientp v)
                                       ($bp! v ($@ ($transpose ($data m)) gradient))
                                       v)))))
  node)

(defmethod $mv ((m node) (v node))
  (let ((result (node ($mv ($data m) ($data v)))))
    (setf ($children result) (list m v))
    (setf ($gradientp result) (or ($gradientp m) ($gradientp v)))
    (setf ($bpfn result) #'mv-backprop)
    result))

(defun mm-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($@ gradient ($transpose ($data b))))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($@ ($transpose ($data a)) gradient))
                                       b)))))
  node)

(defmethod $mm ((a node) (b node))
  (let ((result (node ($mm ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'mm-backprop)
    result))

(defun mul-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($* ($data b) gradient))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($* ($data a) gradient))
                                       b)))))
  node)

(defmethod $mul ((a node) (b node))
  (let ((result (node ($mul ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'mul-backprop)
    result))

(defun bmm-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node))
                                 (y ($c1 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($bmm gradient ($transpose ($data y) 2 1)))
                                       x)
                                   (if ($gradientp y)
                                       ($bp! y ($bmm ($transpose ($data x) 2 1) gradient)))))))
  node)

(defmethod $bmm ((bx node) (by node))
  (let ((result (node ($bmm ($data bx) ($data by)))))
    (setf ($children result) (list bx by))
    (setf ($gradientp result) (or ($gradientp bx) ($gradientp by)))
    (setf ($bpfn result) #'bmm-backprop)
    result))

(defmethod $mml ((x node) (y node))
  (cond ((and (eq 1 ($ndim x)) (eq 1 ($ndim y))) ($dot x y))
        ((and (eq 2 ($ndim x)) (eq 1 ($ndim y))) ($mv x y))
        ((and (eq 2 ($ndim x)) (eq 2 ($ndim y))) ($mm x y))
        ((and (eq 3 ($ndim x)) (eq 3 ($ndim y))) ($bmm x y))))

(defun div-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($div gradient ($data b)))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($neg! ($div ($* ($data a) gradient)
                                                            ($expt ($data b) 2))))
                                       b)))))
  node)

(defmethod $div ((a node) (b node))
  (let ((result (node ($div ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'div-backprop)
    result))

(defun expt-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($mul! ($mul gradient ($data b))
                                                      ($expt ($data a) ($- ($data b) 1))))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($mul! ($mul! ($log ($data a))
                                                             ($expt ($data a) ($data b)))
                                                      gradient))
                                       b)))))
  node)

(defmethod $expt ((a node) (b node))
  (let ((result (node ($expt ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'expt-backprop)
    result))

(defun vv-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node))
                                 (b ($c1 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($mv gradient ($data b)))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($mv ($transpose gradient) ($data a)))
                                       b)))))
  node)

(defmethod $vv ((a node) (b node))
  (let ((result (node ($vv ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'vv-backprop)
    result))

(defun inverse-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node)))
                             (list (if ($gradientp a)
                                       (let ((tnode ($transpose ($data node))))
                                         ($bp! a ($neg ($mm ($mm tnode gradient) tnode)))
                                         a))))))
  node)

(defmethod $inverse ((a node))
  (let ((result (node ($inverse ($data a)))))
    (setf ($children result) (list a))
    (setf ($gradientp result) ($gradientp a))
    (setf ($bpfn result) #'inverse-backprop)
    result))

(defun view-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node)))
                             (list (if ($gradientp a)
                                       ($bp! a ($view gradient ($data a)))
                                       a)))))
  node)

(defmethod $view ((a node) &rest sizes)
  (let ((result (node (apply #'$view ($data a) sizes))))
    (setf ($children result) (list a))
    (setf ($gradientp result) ($gradientp a))
    (setf ($bpfn result) #'view-backprop)
    result))

(defun expand-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($c0 node)))
                             (list (if ($gradientp a)
                                       (let* ((adata ($data a))
                                              (asize ($size adata))
                                              (out gradient))
                                         (loop :for dim :from 0 :below ($count asize)
                                               :for sz = ($ asize dim)
                                               :do (when (eq sz 1)
                                                     (setf out ($sum out dim))))
                                         ($bp! a out))
                                       a)))))
  node)

(defmethod $expand ((a node) size)
  (let ((result (node ($expand ($data a) size))))
    (setf ($children result) (list a))
    (setf ($gradientp result) ($gradientp a))
    (setf ($bpfn result) #'expand-backprop)
    result))

(defun abs-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x (if ($tensorp ($data x))
                                                   ($mul! ($sign ($data x)) gradient)
                                                   ($mul ($sign ($data x)) gradient)))
                                       x)))))
  node)

(defmethod $abs ((x node))
  (let ((result (node ($abs ($data x)))))
    (setf ($children result) x)
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'abs-backprop)
    result))

(defun acos-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($div -1 ($sqrt ($sub 1 ($expt ($data x) 2)))))
                                       x)))))
  node)

(defmethod $acos ((x node))
  (let ((result (node ($acos ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'acos-backprop)
    result))

(defun asin-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($div 1 ($sqrt ($sub 1 ($expt ($data x) 2)))))
                                       x)))))
  node)

(defmethod $asin ((x node))
  (let ((result (node ($asin ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'asin-backprop)
    result))

(defun atan-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($div 1 ($add 1 ($expt ($data x) 2))))
                                       x)))))
  node)

(defmethod $atan ((x node))
  (let ((result (node ($atan ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'atan-backprop)
    result))

(defun atan2-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((y ($c0 node))
                                 (x ($c1 node)))
                             (list (if ($gradientp y)
                                       ($bp! y ($div x ($add ($expt ($data x) 2)
                                                             ($expt ($data y) 2))))
                                       y)
                                   (if ($gradientp x)
                                       ($bp! x ($div ($neg y) ($add ($expt ($data x) 2)
                                                                    ($expt ($data y) 2))))
                                       x)))))
  node)

(defmethod $atan2 ((y node) (x node))
  (let ((result (node ($atan2 ($data y) ($data x)))))
    (setf ($children result) (list y x))
    (setf ($gradientp result) (or ($gradientp y) ($gradientp x)))
    (setf ($bpfn result) #'atan2-backprop)
    result))

(defun cos-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul! ($neg ($sin ($data x))) gradient))
                                       x)))))
  node)

(defmethod $cos ((x node))
  (let ((result (node ($cos ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'cos-backprop)
    result))

(defun cosh-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul ($sinh ($data x)) gradient))
                                       x)))))
  node)

(defmethod $cosh ((x node))
  (let ((result (node ($cosh ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'cosh-backprop)
    result))

(defun exp-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul ($data node) gradient))
                                       x)))))
  node)

(defmethod $exp ((x node))
  (let ((result (node ($exp ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'exp-backprop)
    result))

(defun dlog (x) ($div 1.0 x))

(defun log-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dlog ($data x)) gradient))
                                       x)))))
  node)

(defmethod $log ((x node))
  (let ((result (node ($log ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'log-backprop)
    result))

(defun sin-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul! ($cos ($data x)) gradient))
                                       x)))))
  node)

(defmethod $sin ((x node))
  (let ((result (node ($sin ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'sin-backprop)
    result))

(defun dsigmoid (s) ($* s ($sub 1 s)))

(defun sigmoid-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dsigmoid ($data node)) gradient))
                                       x)))))
  node)

(defmethod $sigmoid ((x node))
  (let ((result (node ($sigmoid ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'sigmoid-backprop)
    result))

(defun sinh-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul ($cosh ($data x)) gradient))
                                       x)))))
  node)

(defmethod $sinh ((x node))
  (let ((result (node ($sinh ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'sinh-backprop)
    result))

(defun sqrt-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul! ($mul gradient 0.5)
                                                      ($expt ($data x) -0.5)))
                                       x)))))
  node)

(defmethod $sqrt ((x node))
  (let ((result (node ($sqrt ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'sqrt-backprop)
    result))

(defun tan-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($mul! ($expt ($cos ($data x)) 2.0) gradient))
                                       x)))))
  node)

(defmethod $tan ((x node))
  (let ((result (node ($tan ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'tan-backprop)
    result))

(defun dtanh (s) ($sub 1 ($* s s)))

(defun tanh-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dtanh ($data node)) gradient))
                                       x)))))
  node)

(defmethod $tanh ((x node))
  (let ((result (node ($tanh ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'tanh-backprop)
    result))

(defgeneric $bce (a b))

(defmethod $bce ((a node) (b node))
  ($dot ($add ($mul ($log a) b)
              ($mul ($log ($sub ($one a) a))
                    ($sub ($one b) b)))
        ($neg ($one a))))

(defun repeat-to-match-shape (x &optional axis)
  (if (not ($tensorp x))
      (lambda (g) (list g 1))
      (if (null axis)
          (lambda (g)
            (list (-> (tensor) ($resize! ($size x)) ($fill! ($sum g)))
                  ($count x)))
          (let ((size (loop :for i :from 0 :below ($ndim x) :collect 1)))
            (setf ($ size axis) ($size x axis))
            (lambda (g)
              (list (apply #'$repeat g size) ($ size axis)))))))

(defun sum-backprop (node gradient dimension)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       (let* ((rs (repeat-to-match-shape ($data x) dimension))
                                              (rfn (car rs)))
                                         ($bp! x (funcall rfn gradient)))
                                       x)))))
  node)

(defmethod $sum ((x node) &optional dimension)
  (let ((result (node ($sum ($data x) dimension))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) (lambda (node gradient) (sum-backprop node gradient dimension)))
    result))

(defun mean-backprop (node gradient dimension)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       (let* ((rs (repeat-to-match-shape ($data x) dimension))
                                              (rfn (car rs))
                                              (rn (cadr rs)))
                                         ($bp! x ($div! (funcall rfn gradient) rn)))
                                       x)))))
  node)

(defmethod $mean ((x node) &optional dimension)
  (let ((result (node ($mean ($data x) dimension))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) (lambda (node gradient) (mean-backprop node gradient dimension)))
    result))

(defun set!-neq (a b v)
  (let ((m ($eq a b)))
    ($mul! ($copy! ($resize! ($empty v) v) m) v)))

(defun min-backprop (node gradient dimension)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       (let* ((rs (repeat-to-match-shape ($data x) dimension))
                                              (rfn (car rs))
                                              (rnodes (funcall rfn ($data node)))
                                              (rgradient (funcall rfn gradient)))
                                         ($bp! x (set!-neq ($data x) rnodes rgradient)))
                                       x)))))
  node)

(defmethod $min ((x node) &optional dimension)
  (let ((result (node ($min ($data x) dimension))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) (lambda (node gradient) (min-backprop node gradient dimension)))
    result))

(defun max-backprop (node gradient dimension)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       (let* ((rs (repeat-to-match-shape ($data x) dimension))
                                              (rfn (car rs))
                                              (rnodes (funcall rfn ($data node)))
                                              (rgradient (funcall rfn gradient)))
                                         ($bp! x (set!-neq ($data x) rnodes rgradient)))
                                       x)))))
  node)

(defmethod $max ((x node) &optional dimension)
  (let ((result (node ($max ($data x) dimension))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) (lambda (node gradient) (max-backprop node gradient dimension)))
    result))

(defun transpose-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($transpose g dimension0 dimension1))
                                       x)))))
  node)

(defmethod $transpose ((x node) &optional dimension0 dimension1)
  (let ((result (node ($transpose ($data x) dimension0 dimension1))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'transpose-backprop)
    result))

(defun conv2-backprop (node gradient type)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node))
                                 (k ($c1 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($xcorr2 gradient ($data k) :full))
                                       x)
                                   (if ($gradientp k)
                                       ($bp! k ($conv2 ($data x) gradient type))
                                       k)))))
  node)

(defmethod $conv2 ((x node) (k node) &optional (type :valid))
  (let ((result (node ($conv2 ($data x) ($data k) type))))
    (setf ($children result) (list x k))
    (setf ($gradientp result) (or ($gradientp x) ($gradientp k)))
    (setf ($bpfn result) (lambda (node gradient) (conv2-backprop node gradient type)))
    result))

(defun xcorr2-backprop (node gradient type)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($c0 node))
                                 (k ($c1 node)))
                             (list (if ($gradientp x)
                                       ($bp! x ($conv2 gradient ($data k) :full))
                                       x)
                                   (if ($gradientp k)
                                       ($bp! k ($xcorr2 ($data x) gradient type))
                                       k)))))
  node)

(defmethod $xcorr2 ((x node) (k node) &optional (type :valid))
  (let ((result (node ($xcorr2 ($data x) ($data k) type))))
    (setf ($children result) (list x k))
    (setf ($gradientp result) (or ($gradientp x) ($gradientp k)))
    (setf ($bpfn result) (lambda (node gradient) (xcorr2-backprop node gradient type)))
    result))
