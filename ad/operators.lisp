(in-package :th)

(defmethod $zero ((x tape)) (tape ($zero ($data x)) ($gradientp x)))
(defmethod $one ((x tape)) (tape ($one ($data x)) ($gradientp x)))
(defmethod $fill ((x tape) value) (tape ($fill ($data x) value) ($gradientp x)))

(defmethod $zero! ((x tape))
  ($zero! ($data x))
  x)
(defmethod $one! ((x tape))
  ($one! ($data x))
  x)
(defmethod $fill! ((x tape) value)
  ($fill! ($data x) value)
  x)

(defun broadcast-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((c ($0 ($children node))))
                             (list (if ($gradientp c)
                                       ($bp! c ($dot ($one ($data node)) gradient))
                                       c)))))
  node)

(defmethod $broadcast ((c tape) (m tape))
  (let ((result (tape ($mul! ($one ($data m)) ($data c)))))
    (setf ($children result) (list c))
    (setf ($gradientp result) ($gradientp c))
    (setf ($bpfn result) #'broadcast-backprop)
    result))

(defun add-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node)
        (mapcar (lambda (c) (if ($gradientp c) ($bp! c gradient) c))
                ($children node)))
  node)

(defmethod $add ((a tape) (b tape))
  (let ((result (tape ($add ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'add-backprop)
    result))

(defun sub-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($0 ($children node)))
                                 (b ($1 ($children node))))
                             (list (if ($gradientp a) ($bp! a gradient) a)
                                   (if ($gradientp b) ($bp! b ($neg gradient)) b)))))
  node)

(defmethod $sub ((a tape) (b tape))
  (let ((result (tape ($sub ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'sub-backprop)
    result))

(defun neg-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($0 ($children node))))
                             (list (if ($gradientp a) ($bp! a ($neg gradient)) a)))))
  node)

(defmethod $neg ((a tape))
  (let ((result (tape ($neg ($data a)))))
    (setf ($children result) (list a))
    (setf ($gradientp result) ($gradientp a))
    (setf ($bpfn result) #'neg-backprop)
    result))

(defun dot-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($0 ($children node)))
                                 (b ($1 ($children node))))
                             (list (if ($gradientp a) ($bp! a ($* ($data b) gradient)) a)
                                   (if ($gradientp b) ($bp! b ($* ($data a) gradient)) b)))))
  node)

(defmethod $dot ((a tape) (b tape))
  (let ((result (tape ($dot ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'dot-backprop)
    result))

(defun mv-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((m ($0 ($children node)))
                                 (v ($1 ($children node))))
                             (list (if ($gradientp m) ($bp! m ($vv gradient ($data v))) m)
                                   (if ($gradientp v)
                                       ($bp! v ($@ ($transpose ($data m)) gradient))
                                       v)))))
  node)

(defmethod $mv ((m tape) (v tape))
  (let ((result (tape ($mv ($data m) ($data v)))))
    (setf ($children result) (list m v))
    (setf ($gradientp result) (or ($gradientp m) ($gradientp v)))
    (setf ($bpfn result) #'mv-backprop)
    result))

(defun mm-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($0 ($children node)))
                                 (b ($1 ($children node))))
                             (list (if ($gradientp a)
                                       ($bp! a ($@ gradient ($transpose ($data b))))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($@ ($transpose ($data a)) gradient))
                                       b)))))
  node)

(defmethod $mm ((a tape) (b tape))
  (let ((result (tape ($mm ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'mm-backprop)
    result))

(defun mul-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((a ($0 ($children node)))
                                 (b ($1 ($children node))))
                             (list (if ($gradientp a)
                                       ($bp! a ($* ($data b) gradient))
                                       a)
                                   (if ($gradientp b)
                                       ($bp! b ($* ($data a) gradient))
                                       b)))))
  node)

(defmethod $mul ((a tape) (b tape))
  (let ((result (tape ($mul ($data a) ($data b)))))
    (setf ($children result) (list a b))
    (setf ($gradientp result) (or ($gradientp a) ($gradientp b)))
    (setf ($bpfn result) #'mul-backprop)
    result))

(defgeneric $bce (a b))

(defmethod $bce ((a tape) (b tape))
  ($dot ($add ($mul ($log a) b)
              ($mul ($log ($sub ($one a) a))
                    ($sub ($one b) b)))
        ($neg ($one a))))


(defun dsigmoid (s) ($* s ($sub 1 s)))

(defun sigmoid-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($0 ($children node))))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dsigmoid ($data node)) gradient))
                                       x)))))
  node)

(defmethod $sigmoid ((x tape))
  (let ((result (tape ($sigmoid ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'sigmoid-backprop)
    result))

(defun dlog (x) ($div 1.0 x))

(defun log-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($0 ($children node))))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dlog ($data x)) gradient))
                                       x)))))
  node)

(defmethod $log ((x tape))
  (let ((result (tape ($log ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'log-backprop)
    result))

(defun dtanh (s) ($sub 1 ($* s s)))

(defun tanh-backprop (node gradient)
  (setf ($gradient node) gradient)
  (setf ($children node) (when ($children node)
                           (let ((x ($0 ($children node))))
                             (list (if ($gradientp x)
                                       ($bp! x ($* (dtanh ($data node)) gradient))
                                       x)))))
  node)

(defmethod $tanh ((x tape))
  (let ((result (tape ($tanh ($data x)))))
    (setf ($children result) (list x))
    (setf ($gradientp result) ($gradientp x))
    (setf ($bpfn result) #'tanh-backprop)
    result))
