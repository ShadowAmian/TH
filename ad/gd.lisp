(in-package :th)

(defgeneric $gd! (node &optional learning-rate) (:documentation "Executes gradient descent."))
(defgeneric $mgd! (node &optional learning-rate momentum) (:documentation "Executes momentum."))
(defgeneric $agd! (node &optional learning-rate) (:documentation "Executes adagrad."))
(defgeneric $amgd! (node &optional learning-rate β1 β2) (:documentation "Executes adam."))
(defgeneric $rmgd! (node &optional learning-rate decay-rate) (:documentation "Executes rmsprop."))

(defmethod $gd! ((object t) &optional (learning-rate 0.01)) (declare (ignore learning-rate)))

(defmethod $gd! ((node node) &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($gd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (setf ($data node) (- data (* grv learning-rate))))
                  (t ($axpy! (- learning-rate) grv data)))
            (setf ($gradient node) nil))))
    node))

(defmethod $mgd! ((object t) &optional (learning-rate 0.01) (momentum 0.9))
  (declare (ignore learning-rate momentum)))

(defmethod $mgd! ((node node) &optional (learning-rate 0.01) (momentum 0.9))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($mgd! c learning-rate momentum))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((v ($ ($attrs node) :v 0)))
                                   (setf v (+ (* grv (- learning-rate)) (* v momentum)))
                                   (setf ($data node) (+ data v))
                                   (setf ($ ($attrs node) :v) v)))
                  (t (let ((v ($ ($attrs node) :v (apply #'zeros ($size grv)))))
                       (setf ($ ($attrs node) :v) ($axpy! (- learning-rate) grv ($mul! v momentum)))
                       ($axpy! 1 ($ ($attrs node) :v) data))))
            (setf ($gradient node) nil))))
    node))

(defmethod $agd! ((object t) &optional (learning-rate 0.01))
  (declare (ignore learning-rate)))

(defmethod $agd! ((node node) &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($agd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((h ($ ($attrs node) :h 1E-8)))
                                   (setf h (+ (* grv grv) h))
                                   (setf ($data node) (- data (* learning-rate (/ grv (sqrt h)))))
                                   (setf ($ ($attrs node) :h) h)))
                  (t (let ((h ($ ($attrs node) :h (-> ($empty grv) ($resize! grv) ($fill! 1E-8)))))
                       (setf ($ ($attrs node) :h) ($add! ($mul grv grv) h))
                       ($axpy! (- learning-rate) ($div grv ($sqrt ($ ($attrs node) :h))) data))))
            (setf ($gradient node) nil))))
    node))

(defmethod $amgd! ((object t) &optional (learning-rate 0.01) (β1 0.9) (β2 0.999))
  (declare (ignore learning-rate β1 β2)))

(defmethod $amgd! ((node node) &optional (learning-rate 0.01) (β1 0.9) (β2 0.999))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($amgd! c learning-rate β1 β2))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((niter ($ ($attrs node) :niteration 1))
                                       (m ($ ($attrs node) :m 0))
                                       (v ($ ($attrs node) :v 0)))
                                   (setf m (+ (* β1 m) (* (- 1 β1) grv)))
                                   (setf v (+ (* β1 v) (* (- 1 β1) (* grv grv))))
                                   (setf ($ ($attrs node) :m) m)
                                   (setf ($ ($attrs node) :v) v)
                                   (setf ($ ($attrs node) :niteration) (1+ niter))
                                   (setf m (/ m (- 1 (expt β1 niter))))
                                   (setf v (/ v (- 1 (expt β2 niter))))
                                   (setf ($data node) (- data (/ (* learning-rate m)
                                                                 (+ (sqrt v) 1E-8))))))
                  (t (let ((niter ($ ($attrs node) :niteration 1))
                           (m ($ ($attrs node) :m (apply #'zeros ($size grv))))
                           (v ($ ($attrs node) :v (apply #'zeros ($size grv))))
                           (clr 0))
                       (setf ($ ($attrs node) :niteration) (1+ niter))
                       (setf clr (/ (* learning-rate (sqrt (- 1 (expt β2 niter))))
                                    (- 1 (expt β1 niter))))
                       ($axpy! (- 1 β1) ($sub grv m) m)
                       ($axpy! (- 1 β2) ($sub! ($expt grv 2) v) v)
                       ($axpy! (- clr) ($div m ($add! ($sqrt v) 1E-8)) data))))
            (setf ($gradient node) nil))))
    node))

(defmethod $rmgd! ((object t) &optional (learning-rate 0.001) (decay-rate 0.99))
  (declare (ignore learning-rate decay-rate)))

(defmethod $rmgd! ((node node) &optional (learning-rate 0.001) (decay-rate 0.99))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($rmgd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((h ($ ($attrs node) :h 0)))
                                   (setf h (* h decay-rate))
                                   (setf h (+ h (* (- 1 decay-rate) grv grv)))
                                   (setf ($ ($attrs node) :h) h)
                                   (setf ($data node) (- data (/ (* learning-rate grv)
                                                                 (+ (sqrt h) 1E-8))))))
                  (t (let ((h ($ ($attrs node) :h (apply #'zeros ($size grv)))))
                       ($mul! h decay-rate)
                       ($axpy! (- 1 decay-rate) ($expt grv 2) h)
                       ($axpy! (- learning-rate) ($div grv ($add! ($sqrt h) 1E-8)) data))))
            (setf ($gradient node) nil))))
    node))
