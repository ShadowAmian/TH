(in-package :th)

(defgeneric $gd! (node &optional learning-rate) (:documentation "Executes gradient descent."))
(defgeneric $mgd! (node &optional learning-rate momentum) (:documentation "Executes momentum."))
(defgeneric $agd! (node &optional learning-rate) (:documentation "Executes adagrad."))

(defmethod $gd! ((object t) &optional (learning-rate 0.01)) (declare (ignore learning-rate)))

(defmethod $gd! ((node node) &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($gd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (setf ($data node) (- data (* grv learning-rate))))
                  (t ($axpy! (- learning-rate) grv data))))))
    node))

(defmethod $mgd! ((object t) &optional (learning-rate 0.01) (momentum 0.9))
  (declare (ignore learning-rate momentum)))

(defmethod $mgd! ((node node) &optional (learning-rate 0.01) (momentum 0.9))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($mgd! c learning-rate momentum))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((v ($ ($attrs node) :v 0)))
                                   (setf v (+ (* grv (- learning-rate)) (* v momentum)))
                                   (setf ($data node) (+ data v))
                                   (setf ($ ($attrs node) :v) v)))
                  (t (let ((v ($ ($attrs node) :v (apply #'zeros ($size grv)))))
                       (setf ($ ($attrs node) :v) ($axpy! (- learning-rate) grv ($mul! v momentum)))
                       ($axpy! 1 ($ ($attrs node) :v) data)))))))
    node))

(defmethod $agd! ((object t) &optional (learning-rate 0.01))
  (declare (ignore learning-rate)))

(defmethod $agd! ((node node) &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($agd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((h ($ ($attrs node) :h 1E-8)))
                                   (setf h (+ (* grv grv) h))
                                   (setf ($data node) (+ data (* (- learning-rate) (/ grv (sqrt h)))))
                                   (setf ($ ($attrs node) :h) h)))
                  (t (let ((h ($ ($attrs node) :h (-> ($empty grv) ($resize! grv) ($fill! 1E-8)))))
                       (setf ($ ($attrs node) :h) ($add! ($mul grv grv) h))
                       ($axpy! (- learning-rate) ($div grv ($sqrt ($ ($attrs node) :h))) data)))))))
    node))
