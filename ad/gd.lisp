(in-package :th)

(defgeneric $gd! (node &optional learning-rate) (:documentation "Executes gradient descent."))
(defgeneric $mgd! (node vs &optional learning-rate momentum)
  (:documentation "Executes momentum."))
(defgeneric $agd! (node hs &optional learning-rate)
  (:documentation "Executes adagrad."))

(defmethod $gd! ((object t) &optional (learning-rate 0.01)) (declare (ignore learning-rate)))

(defmethod $gd! ((node node) &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($gd! c learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (setf ($data node) (- data (* grv learning-rate))))
                  (t ($axpy! (- learning-rate) grv data))))))
    node))

(defmethod $mgd! ((object t) vs &optional (learning-rate 0.01) (momentum 0.9))
  (declare (ignore vs learning-rate momentum)))

(defmethod $mgd! ((node node) vs &optional (learning-rate 0.01) (momentum 0.9))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($mgd! c vs learning-rate momentum))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((v ($ vs node 0)))
                                   (setf v (+ (* grv (- learning-rate)) (* v momentum)))
                                   (setf ($data node) (+ data v))
                                   (setf ($ vs node) v)))
                  (t (let ((v ($ vs node (apply #'zeros ($size grv)))))
                       (setf ($ vs node) ($axpy! (- learning-rate) grv ($mul! v momentum)))
                       ($axpy! 1 ($ vs node) data)))))))
    node))

(defmethod $agd! ((object t) hs &optional (learning-rate 0.01))
  (declare (ignore hs learning-rate)))

(defmethod $agd! ((node node) hs &optional (learning-rate 0.01))
  (let ((children ($children node)))
    (if children
        (loop :for c :in children :do ($agd! c hs learning-rate))
        (when ($gradientp node)
          (let ((data ($data node))
                (grv ($gradient node)))
            (cond ((null grv) nil)
                  ((numberp grv) (let ((h ($ hs node 1E-8)))
                                   (setf h (+ (* grv grv) h))
                                   (setf ($data node) (+ data (* (- learning-rate) (/ grv (sqrt h)))))
                                   (setf ($ hs node) h)))
                  (t (let ((h ($ hs node (-> ($empty grv) ($resize! grv) ($fill! 1E-8)))))
                       (setf ($ hs node) ($add! ($mul grv grv) h))
                       ($axpy! (- learning-rate) ($div grv ($sqrt ($ hs node))) data)))))))
    node))
