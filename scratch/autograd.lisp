(defpackage :th.autograd
  (:use #:common-lisp
        #:mu
        #:th))

(in-package :th.autograd)

(defclass tape ()
  ((data :initform nil :accessor $data)
   (grad :initform nil :accessor $gradient)
   (reqgrd :initform nil :accessor $gradp)
   (children :initform nil :accessor $children)
   (backfn :initform nil :accessor $backfn)))

(defmethod print-object ((tape tape) stream)
  (format stream "[TAPE ~%")
  (print-object ($data tape) stream)
  (format stream "]~%"))

(defgeneric $tapep (object))

(defmethod $tapep ((tape tape)) t)
(defmethod $tapep ((object t)) nil)

(defun tape (data &optional requires-grad-p)
  (let ((n (make-instance 'tape)))
    (setf ($data n) data)
    (setf ($gradp n) requires-grad-p)
    n))

(defmethod $zero ((x tape)) (tape ($zero ($data x))))
(defmethod $fill ((x tape) value) (tape ($fill ($data x) value)))
(defmethod $one ((x tape)) (tape ($one ($data x))))

(defun backfn (x) (or ($backfn x) (lambda (o p) (setf ($gradient o) p) o)))

(defun $bwd (x input) (funcall (backfn x) x input))

(defun broadcast-like (c m)
  (let* ((data ($mul! ($one ($data m)) ($data c)))
         (nt (tape data)))
    (setf ($children nt) (list c))
    (setf ($gradp nt) ($gradp c))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (mapcar (lambda (child)
                                                          (if ($gradp child)
                                                              ($bwd child
                                                                    ($dot ($one ($data m)) grad))
                                                              child))
                                                        ($children node)))
                         node))
    nt))

(let* ((out (broadcast-like (tape 5 t) (tape (tensor '(1 2 3)))))
       (gradient ($bwd out (tensor '(1 2 3)))))
  (print gradient))

(defmethod $add ((a tape) (b tape))
  (let* ((data ($add ($data a) ($data b)))
         (nt (tape data)))
    (setf ($children nt) (list a b))
    (setf ($gradp nt) (or ($gradp a) ($gradp b)))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (mapcar (lambda (child)
                                                          (if ($gradp child)
                                                              ($bwd child grad)
                                                              child))
                                                        ($children node)))
                         node))
    nt))

(let* ((a (tape (tensor '(1 1 1)) t))
       (b (tape (tensor '(1 1 1)) t))
       (out ($add a b))
       (grads ($bwd out (tensor '(1 1 1)))))
  (print grads)
  (print ($children grads)))

(defmethod $sub ((a tape) (b tape))
  (let* ((data ($sub ($data a) ($data b)))
         (nt (tape data)))
    (setf ($children nt) (list a b))
    (setf ($gradp nt) (or ($gradp a) ($gradp b)))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (let ((a ($0 ($children node)))
                                                      (b ($1 ($children node))))
                                                  (list (if ($gradp a)
                                                            ($bwd a grad)
                                                            a)
                                                        (if ($gradp b)
                                                            ($bwd b ($neg grad))
                                                            b))))
                         node))
    nt))

(defmethod $neg ((a tape)) ($sub ($zero a) a))

(let* ((out ($sub (tape (tensor '(1 2 3)))
                  (tape (tensor '(3 2 1)) t)))
       (grads ($bwd out (tensor '(1 1 1)))))
  (print grads)
  (print ($children grads)))

(defmethod $dot ((a tape) (b tape))
  (let* ((data ($dot ($data a) ($data b)))
         (nt (tape data)))
    (setf ($children nt) (list a b))
    (setf ($gradp nt) (or ($gradp a) ($gradp b)))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (let ((a ($0 ($children node)))
                                                      (b ($1 ($children node))))
                                                  (list (if ($gradp a)
                                                            ($bwd a ($mul ($data b) grad))
                                                            a)
                                                        (if ($gradp b)
                                                            ($bwd b ($mul ($data a) grad))
                                                            b))))
                         node))
    nt))

(let* ((x (tensor '(1 2 3)))
       (out ($dot (tape x t) (tape x)))
       (grads ($bwd out 2)))
  (print grads))

(defun gd! (grads)
  (when ($tapep grads)
    (let ((children ($children grads))
          (data ($data grads))
          (grad ($gradient grads))
          (lr 0.01))
      (cond ((null grad) nil)
            ((numberp grad) (setf ($data grads) ($sub data (* grad lr))))
            (t ($axpy! (- lr) grad ($data grads))))
      (when (and children (> ($count children) 0))
        (mapcar #'gd! children))
      grads)))

(let* ((a (tape (tensor '(1 1 1))))
       (b (tape (tensor '(1 2 3)) t))
       (out ($dot a b))
       (grads ($bwd out 1)))
  (print grads)
  (print (gd! grads))
  (print b))

(defmethod $mv ((m tape) (v tape))
  (let* ((data ($mv ($data m) ($data v)))
         (nt (tape data)))
    (setf ($children nt) (list m v))
    (setf ($gradp nt) (or ($gradp m) ($gradp v)))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (list (if ($gradp m)
                                                          ($bwd m ($vv grad ($data v)))
                                                          m)
                                                      (if ($gradp v)
                                                          ($bwd v ($@ ($transpose ($data m))
                                                                      grad))
                                                          v)))
                         node))
    nt))

(defmethod $mm ((a tape) (b tape))
  (let* ((data ($mm ($data a) ($data b)))
         (nt (tape data)))
    (setf ($children nt) (list a b))
    (setf ($gradp nt) (or ($gradp a) ($gradp b)))
    (setf ($backfn nt) (lambda (node grad)
                         (setf ($gradient node) grad)
                         (setf ($children node) (list (if ($gradp a)
                                                          ($bwd a ($@ grad
                                                                      ($transpose ($data b))))
                                                          a)
                                                      (if ($gradp b)
                                                          ($bwd b ($@ ($transpose ($data a))
                                                                      grad))
                                                          b)))
                         node))
    nt))

(let* ((X (tape (tensor '((1) (3)))))
       (Y (tape (tensor '(-10 -30))))
       (c (tape 0 t))
       (b (tape (tensor '(10)) t)))
  (loop :for i :from 0 :below 1000
        :do (let* ((out1 ($sub ($add ($mv X b) (broadcast-like c Y)) Y))
                   (out ($dot out1 out1))
                   (grads ($bwd out 1)))
              (print ($data out))
              (gd! grads)))
  (print b))

(print ($transpose (tensor '((1 3)))))

(print (broadcast-like (tape 0) (tape (tensor '(1 2 3 4)))))

(print ($dot (tensor '(1 2 3)) 2))

(print ($one (tensor '(1 2 3))))

(let* ((a (tape (tensor '(5 5 5))))
       (c (tape 5 t))
       (out (broadcast-like c a))
       (grads ($bwd out (tensor '(1 1 1)))))
  ;; should be same
  (print ($data out))
  (print ($data a))
  ;; should be 3
  (print (-> grads
             ($children)
             ($first)
             ($gradient))))

(let* ((a (tape (tensor '(1 0 -3.21))))
       (b (tape (tensor '(-1.3 2.8 -0.1)))))
  ;; should be 11.3041
  (print ($data ($dot a a)))
  ;; should be -0.979
  (print ($data ($dot a b))))
