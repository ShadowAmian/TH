(defpackage :lstmrev
  (:use #:common-lisp
        #:mu
        #:th))

(in-package :lstmrev)

;; use same data
(defparameter *data* (format nil "~{~A~^~%~}" (read-lines-from "data/tinyshakespeare.txt")))
(defparameter *chars* (remove-duplicates (coerce *data* 'list)))
(defparameter *data-size* ($count *data*))
(defparameter *vocab-size* ($count *chars*))

(defparameter *char-to-idx* (let ((ht #{}))
                              (loop :for i :from 0 :below *vocab-size*
                                    :for ch = ($ *chars* i)
                                    :do (setf ($ ht ch) i))
                              ht))
(defparameter *idx-to-char* *chars*)

(defparameter *hidden-size* 128)
(defparameter *sequence-length* 50)

;; weight seed values - to compare
(defparameter *wa1s* ($* 0.01 (rndn *vocab-size* *hidden-size*)))
(defparameter *ua1s* ($* 0.01 (rndn *hidden-size* *hidden-size*)))
(defparameter *ba1s* (zeros 1 *hidden-size*))

(defparameter *wi1s* ($* 0.01 (rndn *vocab-size* *hidden-size*)))
(defparameter *ui1s* ($* 0.01 (rndn *hidden-size* *hidden-size*)))
(defparameter *bi1s* (zeros 1 *hidden-size*))

(defparameter *wf1s* ($* 0.01 (rndn *vocab-size* *hidden-size*)))
(defparameter *uf1s* ($* 0.01 (rndn *hidden-size* *hidden-size*)))
(defparameter *bf1s* (zeros 1 *hidden-size*))

(defparameter *wo1s* ($* 0.01 (rndn *vocab-size* *hidden-size*)))
(defparameter *uo1s* ($* 0.01 (rndn *hidden-size* *hidden-size*)))
(defparameter *bo1s* (zeros 1 *hidden-size*))

(defparameter *wa2s* ($* 0.01 (rndn *hidden-size* *vocab-size*)))
(defparameter *ua2s* ($* 0.01 (rndn *vocab-size* *vocab-size*)))
(defparameter *ba2s* (zeros 1 *vocab-size*))

(defparameter *wi2s* ($* 0.01 (rndn *hidden-size* *vocab-size*)))
(defparameter *ui2s* ($* 0.01 (rndn *vocab-size* *vocab-size*)))
(defparameter *bi2s* (zeros 1 *vocab-size*))

(defparameter *wf2s* ($* 0.01 (rndn *hidden-size* *vocab-size*)))
(defparameter *uf2s* ($* 0.01 (rndn *vocab-size* *vocab-size*)))
(defparameter *bf2s* (zeros 1 *vocab-size*))

(defparameter *wo2s* ($* 0.01 (rndn *hidden-size* *vocab-size*)))
(defparameter *uo2s* ($* 0.01 (rndn *vocab-size* *vocab-size*)))
(defparameter *bo2s* (zeros 1 *vocab-size*))

;; weights
(defparameter *wa1* ($variable ($clone *wa1s*)))
(defparameter *ua1* ($variable ($clone *ua1s*)))
(defparameter *ba1* ($variable ($clone *ba1s*)))

(defparameter *wi1* ($variable ($clone *wi1s*)))
(defparameter *ui1* ($variable ($clone *ui1s*)))
(defparameter *bi1* ($variable ($clone *bi1s*)))

(defparameter *wf1* ($variable ($clone *wf1s*)))
(defparameter *uf1* ($variable ($clone *uf1s*)))
(defparameter *bf1* ($variable ($clone *bf1s*)))

(defparameter *wo1* ($variable ($clone *wo1s*)))
(defparameter *uo1* ($variable ($clone *uo1s*)))
(defparameter *bo1* ($variable ($clone *bo1s*)))

(defparameter *wa2* ($variable ($clone *wa2s*)))
(defparameter *ua2* ($variable ($clone *ua2s*)))
(defparameter *ba2* ($variable ($clone *ba2s*)))

(defparameter *wi2* ($variable ($clone *wi2s*)))
(defparameter *ui2* ($variable ($clone *ui2s*)))
(defparameter *bi2* ($variable ($clone *bi2s*)))

(defparameter *wf2* ($variable ($clone *wf2s*)))
(defparameter *uf2* ($variable ($clone *uf2s*)))
(defparameter *bf2* ($variable ($clone *bf2s*)))

(defparameter *wo2* ($variable ($clone *wo2s*)))
(defparameter *uo2* ($variable ($clone *uo2s*)))
(defparameter *bo2* ($variable ($clone *bo2s*)))

(loop :for p :from 0 :below (min 1 (- *data-size* *sequence-length* 1)) :by *sequence-length*
      :for input = (let ((m (zeros *sequence-length* *vocab-size*)))
                     (loop :for i :from p :below (+ p *sequence-length*)
                           :for ch = ($ *data* i)
                           :do (setf ($ m (- i p) ($ *char-to-idx* ch)) 1))
                     m)
      :for target = (let ((m (zeros *sequence-length* *vocab-size*)))
                      (loop :for i :from (1+ p) :below (+ p *sequence-length* 1)
                            :for ch = ($ *data* i)
                            :do (setf ($ m (- i p 1) ($ *char-to-idx* ch)) 1))
                      m)
      :do (let ((pout1 ($constant (zeros 1 *hidden-size*)))
                (ps1 ($constant (zeros 1 *hidden-size*)))
                (pout2 ($constant (zeros 1 *vocab-size*)))
                (ps2 ($constant (zeros 1 *vocab-size*)))
                (losses nil))
            (loop :for i :from 0 :below (min 3 *sequence-length*)
                  :for xt = ($constant ($index input 0 i))
                  :for at1 = ($tanh ($+ ($@ xt *wa1*) ($@ pout1 *ua1*) *ba1*))
                  :for it1 = ($sigmoid ($+ ($@ xt *wi1*) ($@ pout1 *ui1*) *bi1*))
                  :for ft1 = ($sigmoid ($+ ($@ xt *wf1*) ($@ pout1 *uf1*) *bf1*))
                  :for ot1 = ($sigmoid ($+ ($@ xt *wo1*) ($@ pout1 *uo1*) *bo1*))
                  :for st1 = ($+ ($* at1 it1) ($* ft1 ps1))
                  :for out1 = ($* ($tanh st1) ot1)
                  :for at2 = ($tanh ($+ ($@ out1 *wa2*) ($@ pout2 *ua2*) *ba2*))
                  :for it2 = ($sigmoid ($+ ($@ out1 *wi2*) ($@ pout2 *ui2*) *bi2*))
                  :for ft2 = ($sigmoid ($+ ($@ out1 *wf2*) ($@ pout2 *uf2*) *bf2*))
                  :for ot2 = ($sigmoid ($+ ($@ out1 *wo2*) ($@ pout2 *uo2*) *bo2*))
                  :for st2 = ($+ ($* at2 it2) ($* ft2 ps2))
                  :for out2 = ($* ($tanh st2) ot2)
                  :for yt = ($softmax out2)
                  :for y = ($constant ($index target 0 i))
                  :for l = ($cee yt y)
                  :do (progn
                        (setf ps1 st1)
                        (setf ps2 st2)
                        (setf pout1 out1)
                        (setf pout2 out2)
                        (push l losses)))
            ($bptt! losses)
            (loop :for p :in (list *wa1* *ua1* *ba1*)
                  :do (prn ($gradient p)))
            ($adgd! ($0 losses))
            (gcf)))

(defparameter *wa1* ($variable ($clone *wa1s*)))
(defparameter *ua1* ($variable ($clone *ua1s*)))
(defparameter *ba1* ($variable ($clone *ba1s*)))

(defparameter *wi1* ($variable ($clone *wi1s*)))
(defparameter *ui1* ($variable ($clone *ui1s*)))
(defparameter *bi1* ($variable ($clone *bi1s*)))

(defparameter *wf1* ($variable ($clone *wf1s*)))
(defparameter *uf1* ($variable ($clone *uf1s*)))
(defparameter *bf1* ($variable ($clone *bf1s*)))

(defparameter *wo1* ($variable ($clone *wo1s*)))
(defparameter *uo1* ($variable ($clone *uo1s*)))
(defparameter *bo1* ($variable ($clone *bo1s*)))

(defparameter *wa2* ($variable ($clone *wa2s*)))
(defparameter *ua2* ($variable ($clone *ua2s*)))
(defparameter *ba2* ($variable ($clone *ba2s*)))

(defparameter *wi2* ($variable ($clone *wi2s*)))
(defparameter *ui2* ($variable ($clone *ui2s*)))
(defparameter *bi2* ($variable ($clone *bi2s*)))

(defparameter *wf2* ($variable ($clone *wf2s*)))
(defparameter *uf2* ($variable ($clone *uf2s*)))
(defparameter *bf2* ($variable ($clone *bf2s*)))

(defparameter *wo2* ($variable ($clone *wo2s*)))
(defparameter *uo2* ($variable ($clone *uo2s*)))
(defparameter *bo2* ($variable ($clone *bo2s*)))

(loop :for p :from 0 :below (min 1 (- *data-size* *sequence-length* 1)) :by *sequence-length*
      :for input = (let ((m (zeros *sequence-length* *vocab-size*)))
                     (loop :for i :from p :below (+ p *sequence-length*)
                           :for ch = ($ *data* i)
                           :do (setf ($ m (- i p) ($ *char-to-idx* ch)) 1))
                     m)
      :for target = (let ((m (zeros *sequence-length* *vocab-size*)))
                      (loop :for i :from (1+ p) :below (+ p *sequence-length* 1)
                            :for ch = ($ *data* i)
                            :do (setf ($ m (- i p 1) ($ *char-to-idx* ch)) 1))
                      m)
      :do (let ((outs1 ($state (zeros 1 *hidden-size*)))
                (states1 ($state (zeros 1 *hidden-size*)))
                (outs2 ($state (zeros 1 *vocab-size*)))
                (states2 ($state (zeros 1 *vocab-size*)))
                (losses nil))
            (loop :for i :from 0 :below (min 3 *sequence-length*)
                  :for xt = ($constant ($index input 0 i))
                  :for at1 = ($tanh ($+ ($@ xt *wa1*) ($@ ($prev outs1) *ua1*) *ba1*))
                  :for it1 = ($sigmoid ($+ ($@ xt *wi1*) ($@ ($prev outs1) *ui1*) *bi1*))
                  :for ft1 = ($sigmoid ($+ ($@ xt *wf1*) ($@ ($prev outs1) *uf1*) *bf1*))
                  :for ot1 = ($sigmoid ($+ ($@ xt *wo1*) ($@ ($prev outs1) *uo1*) *bo1*))
                  :for st1 = ($+ ($* at1 it1) ($* ft1 ($prev states1)))
                  :for out1 = ($* ($tanh st1) ot1)
                  :for at2 = ($tanh ($+ ($@ out1 *wa2*) ($@ ($prev outs2) *ua2*) *ba2*))
                  :for it2 = ($sigmoid ($+ ($@ out1 *wi2*) ($@ ($prev outs2) *ui2*) *bi2*))
                  :for ft2 = ($sigmoid ($+ ($@ out1 *wf2*) ($@ ($prev outs2) *uf2*) *bf2*))
                  :for ot2 = ($sigmoid ($+ ($@ out1 *wo2*) ($@ ($prev outs2) *uo2*) *bo2*))
                  :for st2 = ($+ ($* at2 it2) ($* ft2 ($prev states2)))
                  :for out2 = ($* ($tanh st2) ot2)
                  :for yt = ($softmax out2)
                  :for y = ($constant ($index target 0 i))
                  :for l = ($cee yt y)
                  :do (progn
                        ($update! states1 st1)
                        ($update! states2 st2)
                        ($update! outs1 out1)
                        ($update! outs2 out2)
                        (push l losses)))
            ($bptt! losses states1 states2 outs1 outs2)
            (loop :for p :in (list *wa1* *ua1* *ba1*)
                  :do (prn ($gradient p)))
            ($adgd! ($0 losses))
            (gcf)))
