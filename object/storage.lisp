(in-package :th)

(defclass th.object () ((handle :initform nil :accessor $handle)))
(defmethod $handle (null) +nil+)

(defclass storage (th.object) ())
(defclass storage.integral (storage) ())
(defclass storage.fractional (storage) ())

(defclass storage.byte (storage.integral) ())
(defclass storage.char (storage.integral) ())
(defclass storage.short (storage.integral) ())
(defclass storage.int (storage.integral) ())
(defclass storage.long (storage.integral) ())
(defclass storage.float (storage.fractional) ())
(defclass storage.double (storage.fractional) ())

(defclass pointer (th.object) ())
(defclass pointer.integral (pointer) ())
(defclass pointer.fractional (pointer) ())

(defclass pointer.byte (pointer.integral) ())
(defclass pointer.char (pointer.integral) ())
(defclass pointer.short (pointer.integral) ())
(defclass pointer.int (pointer.integral) ())
(defclass pointer.long (pointer.integral) ())
(defclass pointer.float (pointer.fractional) ())
(defclass pointer.double (pointer.fractional) ())

(defmethod $type ((pointer pointer.byte)) :unsigned-char)
(defmethod $type ((pointer pointer.char)) :char)
(defmethod $type ((pointer pointer.short)) :short)
(defmethod $type ((pointer pointer.int)) :int)
(defmethod $type ((pointer pointer.long)) :long)
(defmethod $type ((pointer pointer.float)) :float)
(defmethod $type ((pointer pointer.double)) :double)

(defmethod $coerce ((pointer pointer.byte) value) (coerce value 'unsigned-byte))
(defmethod $coerce ((pointer pointer.char) value) (coerce value 'signed-byte))
(defmethod $coerce ((pointer pointer.short) value) (coerce value 'integer))
(defmethod $coerce ((pointer pointer.int) value) (coerce value 'integer))
(defmethod $coerce ((pointer pointer.long) value) (coerce value 'integer))
(defmethod $coerce ((pointer pointer.float) value) (coerce value 'single-float))
(defmethod $coerce ((pointer pointer.double) value) (coerce value 'double-float))

(defmethod $ ((pointer pointer) location &rest others-and-default)
  (declare (ignore others-and-default))
  (cffi:mem-aref ($handle pointer) ($type pointer) location))

(defmethod (setf $) (value (pointer pointer.byte) location &rest others)
  (declare (ignore others))
  (setf (cffi:mem-aref ($handle pointer) ($type pointer) location)
        ($coerce pointer value)))

(defgeneric allocate-storage (storage &optional size))

(defmethod allocate-storage ((storage storage.byte) &optional size)
  (let ((handle (if size
                    (th-byte-storage-new-with-size size)
                    (th-byte-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-byte-storage-free handle)))))
(defmethod allocate-storage ((storage storage.char) &optional size)
  (let ((handle (if size
                    (th-char-storage-new-with-size size)
                    (th-char-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-char-storage-free handle)))))
(defmethod allocate-storage ((storage storage.short) &optional size)
  (let ((handle (if size
                    (th-short-storage-new-with-size size)
                    (th-short-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-short-storage-free handle)))))
(defmethod allocate-storage ((storage storage.int) &optional size)
  (let ((handle (if size
                    (th-int-storage-new-with-size size)
                    (th-int-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-int-storage-free handle)))))
(defmethod allocate-storage ((storage storage.long) &optional size)
  (let ((handle (if size
                    (th-long-storage-new-with-size size)
                    (th-long-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-long-storage-free handle)))))
(defmethod allocate-storage ((storage storage.float) &optional size)
  (let ((handle (if size
                    (th-float-storage-new-with-size size)
                    (th-float-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-float-storage-free handle)))))
(defmethod allocate-storage ((storage storage.double) &optional size)
  (let ((handle (if size
                    (th-double-storage-new-with-size size)
                    (th-double-storage-new))))
    (setf ($handle storage) handle)
    (sb-ext:finalize storage (lambda () (th-double-storage-free handle)))))

(defun make-storage (cls &optional size-or-contents)
  (let ((storage (make-instance cls)))
    (cond ((or (listp size-or-contents) ($tensorp size-or-contents))
           (let ((sz ($count size-or-contents))
                 (contents size-or-contents))
             (allocate-storage storage sz)
             (loop :for i :from 0 :below ($count contents)
                   :do (setf ($ storage i) ($ contents i)))))
          (t (allocate-storage storage size-or-contents)))
    storage))

(defun storage.byte (&optional size-or-contents) (make-storage 'storage.byte size-or-contents))
(defun storage.char (&optional size-or-contents) (make-storage 'storage.char size-or-contents))
(defun storage.short (&optional size-or-contents) (make-storage 'storage.short size-or-contents))
(defun storage.int (&optional size-or-contents) (make-storage 'storage.int size-or-contents))
(defun storage.long (&optional size-or-contents) (make-storage 'storage.long size-or-contents))
(defun storage.float (&optional size-or-contents) (make-storage 'storage.float size-or-contents))
(defun storage.double (&optional size-or-contents) (make-storage 'storage.double size-or-contents))

(defmethod $empty ((storage storage)) (make-storage (type-of storage)))

(defun irange (from below) (loop :for i :from from :below below :collect i))
(defun elmn (storage n)
  (let ((p ($pointer storage)))
    (mapcar (lambda (i) ($ p i)) (loop :for i :from 0 :below n :collect i))))
(defun print-storage-object (storage fmt stream)
  (let ((n ($count storage)))
    (format stream fmt (type-of storage) n (elmn storage (min 5 n)) (if (> n 5) " ...]" "]"))))

(defmethod print-object ((storage storage.integral) stream)
  (print-storage-object storage "#<~A (~A) [~{~4D~^ ~}~A>" stream))
(defmethod print-object ((storage storage.fractional) stream)
  (print-storage-object storage "#<~A ~A [~{~,4E~^ ~}~A>" stream))

(defmethod $type ((storage storage.byte)) :unsigned-char)
(defmethod $type ((storage storage.char)) :char)
(defmethod $type ((storage storage.short)) :short)
(defmethod $type ((storage storage.int)) :int)
(defmethod $type ((storage storage.long)) :long)
(defmethod $type ((storage storage.float)) :float)
(defmethod $type ((storage storage.double)) :double)

(defmethod $coerce ((storage storage.byte) value) (coerce value 'unsigned-byte))
(defmethod $coerce ((storage storage.char) value) (coerce value 'signed-byte))
(defmethod $coerce ((storage storage.short) value) (coerce value 'integer))
(defmethod $coerce ((storage storage.int) value) (coerce value 'integer))
(defmethod $coerce ((storage storage.long) value) (coerce value 'integer))
(defmethod $coerce ((storage storage.float) value) (coerce value 'single-float))
(defmethod $coerce ((storage storage.double) value) (coerce value 'double-float))

(defun make-pointer (cls p)
  (let ((pointer (make-instance cls)))
    (setf ($handle pointer) p)
    pointer))

(defmethod $pointer ((storage storage.byte))
  (make-pointer 'pointer.byte (th-byte-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.char))
  (make-pointer 'pointer.char (th-char-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.short))
  (make-pointer 'pointer.short (th-short-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.int))
  (make-pointer 'pointer.int (th-int-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.long))
  (make-pointer 'pointer.long (th-long-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.float))
  (make-pointer 'pointer.float (th-float-storage-data ($handle storage))))
(defmethod $pointer ((storage storage.double))
  (make-pointer 'pointer.double (th-double-storage-data ($handle storage))))

(defmethod $storagep ((storage storage)) t)
(defmethod $storagep ((storage t)) nil)
