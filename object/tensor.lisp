(in-package :th)

(defclass tensor (th.object) ())
(defclass tensor.integral (tensor) ())
(defclass tensor.fractional (tensor) ())

(defclass tensor.byte (tensor.integral) ())
(defclass tensor.char (tensor.integral) ())
(defclass tensor.short (tensor.integral) ())
(defclass tensor.int (tensor.integral) ())
(defclass tensor.long (tensor.integral) ())
(defclass tensor.float (tensor.fractional) ())
(defclass tensor.double (tensor.fractional) ())

(defgeneric allocate-tensor (tensor &optional dimensions))

(defmethod allocate-tensor ((tensor tensor.byte) &optional dimensions)
  (let ((handle (if dimensions
                    (th-byte-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-byte-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-byte-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.char) &optional dimensions)
  (let ((handle (if dimensions
                    (th-char-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-char-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-char-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.short) &optional dimensions)
  (let ((handle (if dimensions
                    (th-short-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-short-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-short-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.int) &optional dimensions)
  (let ((handle (if dimensions
                    (th-int-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-int-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-int-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.long) &optional dimensions)
  (let ((handle (if dimensions
                    (th-long-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-long-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-long-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.float) &optional dimensions)
  (let ((handle (if dimensions
                    (th-float-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-float-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-float-tensor-free handle)))))
(defmethod allocate-tensor ((tensor tensor.double) &optional dimensions)
  (let ((handle (if dimensions
                    (th-double-tensor-new-with-size ($handle (storage.long dimensions)) +nil+)
                    (th-double-tensor-new))))
    (setf ($handle tensor) handle)
    (sb-ext:finalize tensor (lambda () (th-double-tensor-free handle)))))

(defun mkdims (seqs)
  (if (listp seqs)
      (cons ($count seqs) (mkdims (car seqs)))
      nil))

(defun setseqs (ts seqs dims)
  (let ((nd ($count dims)))
    (cond ((eq nd 1) (loop :for i :from 0 :below ($0 dims)
                           :do (setf (tensor-at ts i) ($ seqs i))))
          ((eq nd 2) (loop :for i :from 0 :below ($0 dims)
                           :do (loop :for j :from 0 :below ($1 dims)
                                     :for v = ($ ($ seqs i) j)
                                     :do (setf (tensor-at ts i j) v))))
          ((eq nd 3) (loop :for i :from 0 :below ($0 dims)
                           :do (loop :for j :from 0 :below ($1 dims)
                                     :do (loop :for k :from 0 :below ($2 dims)
                                               :for v = ($ ($ ($ seqs i) j) k)
                                               :do (setf (tensor-at ts i j k) v)))))
          ((eq nd 4) (loop :for i :from 0 :below ($0 dims)
                           :do (loop :for j :from 0 :below ($1 dims)
                                     :do (loop :for k :from 0 :below ($2 dims)
                                               :do (loop :for l :from 0 :below ($3 dims)
                                                         :for v = ($ ($ ($ ($ seqs i) j) k) l)
                                                         :do (setf (tensor-at ts i j k l) v)))))))
    ts))

(defun make-tensor (cls &optional dimensions)
  (let ((tensor (make-instance cls)))
    (allocate-tensor tensor dimensions)
    tensor))

(defun make-tensor-seqs (cls seqs)
  (let* ((dims (mkdims seqs))
         (tensor (make-tensor cls dims)))
    (setseqs tensor seqs dims)))

(defun make-tensor-args (cls args)
  (cond ((and (eq 1 ($count args)) (listp (car args))) (make-tensor-seqs cls (car args)))
        ((and (eq 1 ($count args)) ($tensorp (car args)))
         (if (typep (car args) cls)
             (tensor-with-tensor (car args))
             (let ((nt (make-tensor cls))
                   (src (car args)))
               (tensor-resize-as nt src)
               (tensor-copy nt src)
               nt)))
        ((and (eq 2 ($count args)) (listp ($0 args)) (listp ($1 args)))
         (tensor-with-storage nil 0 ($0 args) ($1 args)))
        (($storagep (car args)) (apply #'tensor-with-storage args))
        (t (make-tensor cls args))))

(defun tensor.byte (&rest args) (make-tensor-args 'tensor.byte args))
(defun tensor.char (&rest args) (make-tensor-args 'tensor.char args))
(defun tensor.short (&rest args) (make-tensor-args 'tensor.short args))
(defun tensor.int (&rest args) (make-tensor-args 'tensor.int args))
(defun tensor.long (&rest args) (make-tensor-args 'tensor.long args))
(defun tensor.float (&rest args) (make-tensor-args 'tensor.float args))
(defun tensor.double (&rest args) (make-tensor-args 'tensor.double args))

(defparameter *default-tensor-class* 'tensor.double)

(defun tensor (&rest args) (make-tensor-args *default-tensor-class* args))

(defmethod $empty ((tensor tensor)) (make-tensor (type-of tensor)))

(defun print-1d-int4 (tensor stream)
  (format stream "#<~A ~A>" (type-of tensor) ($size tensor))
  (let* ((n0 (car ($size tensor)))
         (n n0)
         (tr? nil)
         (maxn 8)
         (halfn 4))
    (when (> n maxn)
      (setf n maxn)
      (setf tr? t))
    (format stream "~%|")
    (loop :for i :from 0 :below n
          :do (let* ((i (if (and tr? (>= i halfn)) (- n0 (- maxn i)) i))
                     (v (tensor-at tensor i)))
                (if (< i (1- n0))
                    (if (and tr? (= i (- n0 halfn)))
                        (format stream " ··· ~4D " v)
                        (format stream "~4D " v))
                    (format stream "~4D|" v))))
    (format stream "~%")))

(defun print-2d-int4 (tensor stream)
  (let* ((sz ($size tensor))
         (nr0 ($0 sz))
         (nc0 ($1 sz))
         (nr nr0)
         (nc nc0)
         (maxn 8)
         (halfn 4)
         (rtr? nil)
         (ctr? nil))
    (when (> nr maxn)
      (setf rtr? t)
      (setf nr maxn))
    (when (> nc maxn)
      (setf ctr? t)
      (setf nc maxn))
    (format stream "#<~A ~A>~%" (type-of tensor) sz)
    (loop :for i :from 0 :below nr
          :do (let ((i (if (and rtr? (>= i halfn)) (- nr0 (- maxn i)) i)))
                (format stream "|")
                (loop :for j :from 0 :below nc
                      :do (let* ((j (if (and ctr? (>= j halfn)) (- nc0 (- maxn j)) j))
                                 (v (tensor-at tensor i j)))
                            (if (< j (1- nc0))
                                (if (and ctr? (= j (- nc0 halfn)))
                                    (format stream " ··· ~4D " v)
                                    (format stream "~4D " v))
                                (format stream "~4D|" v))))
                (if (and rtr? (= i (1- halfn)))
                    (format stream "~%~%   ···~%~%")
                    (format stream "~%"))))))

(defun print-1d-int6 (tensor stream)
  (format stream "#<~A ~A>" (type-of tensor) ($size tensor))
  (let* ((n0 (car ($size tensor)))
         (tr? nil)
         (n n0)
         (maxn 8)
         (halfn 4))
    (when (> n maxn)
      (setf n maxn)
      (setf tr? t))
    (format stream "~%|")
    (loop :for i :from 0 :below n
          :do (let* ((i (if (and tr? (>= i halfn)) (- n0 (- maxn i)) i))
                     (v (tensor-at tensor i)))
                (if (< i (1- n0))
                    (if (and tr? (= i (- n0 halfn)))
                        (format stream " ··· ~6D " v)
                        (format stream "~6D " v))
                    (format stream "~4D" v))))
    (format stream "|~%")))

(defun print-2d-int6 (tensor stream)
  (let* ((sz ($size tensor))
         (nr0 ($0 sz))
         (nc0 ($1 sz))
         (nr nr0)
         (nc nc0)
         (maxn 8)
         (halfn 4)
         (rtr? nil)
         (ctr? nil))
    (when (> nr maxn)
      (setf rtr? t)
      (setf nr maxn))
    (when (> nc maxn)
      (setf ctr? t)
      (setf nc maxn))
    (format stream "#<~A ~A>~%" (type-of tensor) sz)
    (loop :for i :from 0 :below nr
          :do (let ((i (if (and rtr? (>= i halfn)) (- nr0 (- maxn i)) i)))
                (format stream "|")
                (loop :for j :from 0 :below nc
                      :do (let* ((j (if (and ctr? (>= j halfn)) (- nc0 (- maxn j)) j))
                                 (v (tensor-at tensor i j)))
                            (if (< j (1- nc0))
                                (if (and ctr? (= j (- nc0 halfn)))
                                    (format stream " ··· ~6D " v)
                                    (format stream "~6D " v))
                                (format stream "~6D|" v))))
                (if (and rtr? (= i (1- halfn)))
                    (format stream "~%~%   ···~%~%")
                    (format stream "~%"))))))

(defun print-1d-int12 (tensor stream)
  (format stream "#<~A ~A>" (type-of tensor) ($size tensor))
  (let* ((n0 (car ($size tensor)))
         (n n0)
         (tr? nil)
         (maxn 8)
         (halfn 4))
    (when (> n maxn)
      (setf n maxn)
      (setf tr? t))
    (format stream "~%|")
    (loop :for i :from 0 :below n
          :do (let* ((i (if (and tr? (>= i halfn)) (- n0 (- maxn i)) i))
                     (v (tensor-at tensor i)))
                (if (< i (1- n0))
                    (if (and tr? (= i (- n0 halfn)))
                        (format stream " ··· ~11D " v)
                        (format stream "~11D " v))
                    (format stream "~11D" v))))
    (format stream "|~%")))

(defun print-2d-int12 (tensor stream)
  (let* ((sz ($size tensor))
         (nr0 ($0 sz))
         (nc0 ($1 sz))
         (nr nr0)
         (nc nc0)
         (maxn 8)
         (halfn 4)
         (rtr? nil)
         (ctr? nil))
    (when (> nr maxn)
      (setf rtr? t)
      (setf nr maxn))
    (when (> nc maxn)
      (setf ctr? t)
      (setf nc maxn))
    (format stream "#<~A ~A>~%" (type-of tensor) sz)
    (loop :for i :from 0 :below nr
          :do (let ((i (if (and rtr? (>= i halfn)) (- nr0 (- maxn i)) i)))
                (format stream "|")
                (loop :for j :from 0 :below nc
                      :do (let* ((j (if (and ctr? (>= j halfn)) (- nc0 (- maxn j)) j))
                                 (v (tensor-at tensor i j)))
                            (if (< j (1- nc0))
                                (if (and ctr? (= j (- nc0 halfn)))
                                    (format stream " ··· ~11D " v)
                                    (format stream "~11D " v))
                                (format stream "~11D|" v))))
                (if (and rtr? (= i (1- halfn)))
                    (format stream "~%~%   ···~%~%")
                    (format stream "~%"))))))

(defun print-1d-f12 (tensor stream)
  (format stream "#<~A ~A>" (type-of tensor) ($size tensor))
  (let* ((n0 (car ($size tensor)))
         (n n0)
         (tr? nil)
         (maxn 8)
         (halfn 4))
    (when (> n maxn)
      (setf n maxn)
      (setf tr? t))
    (format stream "~%|")
    (loop :for i :from 0 :below n
          :do (let* ((i (if (and tr? (>= i halfn)) (- n0 (- maxn i)) i))
                     (v (tensor-at tensor i)))
                (if (< i (1- n0))
                    (if (and tr? (eq i (- n0 halfn)))
                        (format stream " ··· ~11,4E " v)
                        (format stream "~11,4E " v))
                    (format stream "~11,4E" v))))
    (format stream "|~%")))

(defun print-2d-f12 (tensor stream)
  (let* ((sz ($size tensor))
         (nr0 ($0 sz))
         (nc0 ($1 sz))
         (nr nr0)
         (nc nc0)
         (maxn 8)
         (halfn 4)
         (rtr? nil)
         (ctr? nil))
    (when (> nr maxn)
      (setf rtr? t)
      (setf nr maxn))
    (when (> nc maxn)
      (setf ctr? t)
      (setf nc maxn))
    (format stream "#<~A ~A>~%" (type-of tensor) sz)
    (loop :for i :from 0 :below nr
          :do (let ((i (if (and rtr? (>= i halfn)) (- nr0 (- maxn i)) i)))
                (format stream "|")
                (loop :for j :from 0 :below nc
                      :do (let* ((j (if (and ctr? (>= j halfn)) (- nc0 (- maxn j)) j))
                                 (v (tensor-at tensor i j)))
                            (if (< j (1- nc0))
                                (if (and ctr? (= j (- nc0 halfn)))
                                    (format stream " ··· ~11,4E " v)
                                    (format stream "~11,4E " v))
                                (format stream "~11,4E|" v))))
                (if (and rtr? (= i (1- halfn)))
                    (format stream "~%~%   ···~%~%")
                    (format stream "~%"))))))

(defun print-3d (tensor stream)
  (let ((n0 ($ ($size tensor) 0)))
    (format stream "#<~A ~A>~%" (type-of tensor) ($size tensor))
    (loop :for i :from 0 :below (min 5 n0)
          :do (format stream "[~A,]~%~A" i ($ tensor i)))
    (if (>= n0 5)
        (format stream "[5,] ···~%"))))

(defun print-f12 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~11,4E~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int4 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~4D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int6 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~6D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defun print-int12 (storage tensor stream)
  (let ((n (min ($size storage) (tensor-n-element tensor))))
    (format stream "#<~A ~A [~{~11D~^ ~}~A>" (type-of tensor) ($size tensor)
            (loop :for i :from 0 :below (min 5 n) :collect ($ storage i))
            (if (>= n 5) " ···]" "]"))))

(defmethod print-object ((tensor tensor.fractional) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-f12 tensor stream))
                ((eq 2 ($count sz)) (print-2d-f12 tensor stream))
                ((eq 3 ($count sz)) (print-3d tensor stream))
                (t (print-f12 storage tensor stream))))
        (format stream "#<~A ~A []>" (type-of tensor) ($size tensor)))))

(defmethod print-object ((tensor tensor.integral) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-int12 tensor stream))
                ((eq 2 ($count sz)) (print-2d-int12 tensor stream))
                ((eq 3 ($count sz)) (print-3d tensor stream))
                (t (print-int4 storage tensor stream))))
        (format stream "#<~A ~A []>" (type-of tensor) ($size tensor)))))

(defmethod print-object ((tensor tensor.byte) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-int4 tensor stream))
                ((eq 2 ($count sz)) (print-2d-int4 tensor stream))
                ((eq 3 ($count sz)) (print-3d tensor stream))
                (t (print-int4 storage tensor stream))))
        (format stream "#<~A ~A []>" (type-of tensor) ($size tensor)))))

(defmethod print-object ((tensor tensor.char) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-int4 tensor stream))
                ((eq 2 ($count sz)) (print-2d-int4 tensor stream))
                ((eq 3 ($count sz)) (print-3d tensor stream))
                (t (print-int4 storage tensor stream))))
        (format stream "#<~A ~A []>" (type-of tensor) ($size tensor)))))

(defmethod print-object ((tensor tensor.short) stream)
  (let ((storage ($storage tensor)))
    (if storage
        (let ((sz ($size tensor)))
          (cond ((eq 1 ($count sz)) (print-1d-int6 tensor stream))
                ((eq 2 ($count sz)) (print-2d-int6 tensor stream))
                ((eq 3 ($count sz)) (print-3d tensor stream))
                (t (print-int6 storage tensor stream))))
        (format stream "#<~A ~A []>" (type-of tensor) ($size tensor)))))

(defmethod $tensorp ((tensor tensor)) t)
(defmethod $tensorp ((tensot t)) nil)
